
<!DOCTYPE html>
<html>
<head>
<style type="text/css">
body{
    line-height:1.6;
    font-size:18px;
    color:#eee;
    background-color:#222;
}
</style>
</head>
<body>
<form id="the-form">
  <input id="the-input" name="the-input" type="number" required />

  <button id="the-submit-button" type="submit">Submit</button>
</form>
<span id="error-output"></span>

<div id="the-list"></div>
</body>
<script>
const theForm = document.getElementById("the-form")
const numberInput = document.getElementById("the-input")
const errorOutput = document.getElementById("error-output")
const listParent = document.getElementById("the-list")

function isPalindrome(s) {
    s = s.trim().toLowerCase().replaceAll(/[\W]+/g, "")
    return  s.split("").reverse().join("") === s
}

function toPairs(inputArray) {
  return Array.from(
    {length: inputArray.length - 1},
    (_, index) => inputArray.slice(index, index+2)
  )
}

function numberDisplay(n, radix) {
    const prefix = 
        radix === 10
            ? ""
            : radix === 16 
                ? "0x" 
                : radix === 2
                    ? "0b"
                    : "0?"
    return prefix + n.toString(radix)
}

function isNiceNumber(n) {
    if (!Number.isInteger(n)) {
        return {isNice: false, message: "Not even an integer"}
    }
    
    for (radix of [10, 16, 2]) {
        const s = n.toString(radix)
    
        if (radix !== 2 && isPalindrome(s)) {
            return {isNice: true, numberText: numberDisplay(s, radix), message: "palindrome"}
        }
        
        const digits = s.split("").map(x => parseInt(x, radix))
        
        if (
            radix !== 2
            && digits.every(digit => digit === 0 || digit === 1)
        ) {
            return {isNice: true, numberText: numberDisplay(s, radix), message: "looks like binary"}
        }
        
        if (digits.length > 2) {
            let multiples = []
            for (let i = 2; i <= radix; i += 1) {
                // These could be just the primes, but  we get the right
                // answer becasue we go lowest to highest, and the 
                // redundant checks are currently fast enough we haven't
                // noticed an issue
                multiples.push(i);
            }
            
            for (multiple of multiples) {
                let allInProductOrder = true
                
                for ([digitA, digitB] of toPairs(digits)) {
                    if (digitA * multiple !== digitB) {
                        allInProductOrder = false
                        break
                    }
                }
                
                if (allInProductOrder) {
                    return {isNice: true, numberText: numberDisplay(s, radix), message: "all in product order"}
                }
                
                let reversed = [...digits].reverse()
                
                allInProductOrder = true
                
                for ([digitA, digitB] of toPairs(reversed)) {
                    if (digitA * multiple !== digitB) {
                        allInProductOrder = false
                        break
                    }
                }
                
                if (allInProductOrder) {
                    return {isNice: true, numberText: numberDisplay(s, radix), message: "all in product order (reversed)"}
                }
            }
            
            
        }
        
        const differences =
            toPairs(digits)
                .map(([a, b]) => a - b)

        const hasEvenlySpacedDigits =
            toPairs(differences)
                .every(([a, b]) => a === b)
        
        if (differences.length > 1 && hasEvenlySpacedDigits) {
            return {isNice: true, numberText: numberDisplay(s, radix), message: "evenly spaced digits"}
        }
        
        if (s.match(/69/) !== null) {
            return {isNice: true, numberText: numberDisplay(s, radix), message: "funny sex number"}
        }
        
        if (s.match(/42/) !== null) {
            return {isNice: true, numberText: numberDisplay(s, radix), message: "the answer"}
        }
    }
    
    return {isNice: false, numberText: "", message: ""}
}

function onSubmit(event){
    event.preventDefault()

    const startNumber = parseInt(numberInput.value);
    
    listParent.textContent = ""
    
    const isANumber = !isNaN(startNumber)
    if (isANumber) {
        errorOutput.innerText = ""
    } else {
        errorOutput.innerText = `"${numberInput.value}" could not be parsed as an integer.`
    }

    const count = 10
    
    let entries = []
    
    let currentNumber = startNumber + 1
    let i = 0
    // Number.MAX_SAFE_INTEGER is 9007199254740991, which has been 
    // manually verified to not be nice
    while (entries.length < count && currentNumber < Number.MAX_SAFE_INTEGER) {
        const {isNice, numberText, message} = isNiceNumber(currentNumber)
        
        if (isNice) {
            entries.push({n: currentNumber, numberText, message})
        }
        currentNumber += 1
    }

    for (obj of entries) {
        const {n, numberText, message} = obj
        const p = document.createElement("p")

        p.textContent = (String(n) === numberText ? n : (n + " (" + numberText + ")")) + ": " + message

        listParent.appendChild(p)
    }
}

theForm.onsubmit = onSubmit

</script>
</html>
